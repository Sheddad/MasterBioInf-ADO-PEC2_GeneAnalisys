---
title: "PEC 2 Anàlisis de Dades Òmiques"
author: "Sheddad Kaid-Salah Ferrón"
date: "`r format(Sys.Date())`"
params:
  printcode:
    label: "Display Code:"
    value: TRUE # or set it to FALSE
output:
   html_document:
    code_folding: hide
    toc: true
    toc_float: no
    toc_depth: 3
    theme: flatly
    highlight: textmate
    number_sections: true
    csl: vancouver.csl
editor_options: 
  chunk_output_type: console
bibliography: PEC2_ADO_Ref.bib
---

```{r class.source = 'fold-hide', setup, include=FALSE}
library(knitr)
library(rmdformats)

## Global options
options(max.print="75")
opts_chunk$set(echo=TRUE,
	             cache=FALSE,
               prompt=FALSE,
               tidy=TRUE,
               comment=NA,
               message=FALSE,
               warning=FALSE)
opts_knit$set(width=75)
```

# Introducció i Objectius

Amb aquesta activitat es pretén fer una introducció de forma pràctica a l'ús de 
R per a la gestió de dades de microarrays.  
Força dades òmiques, un cop processades, es poden emmagatzemar com a dades 
numèriques que es poden representar com "matriu de dades" en la que els gens 
(variables) estan en files i les mostres (individus) estan en columnes.  
Tot i això, el conjunt d’aquestes dades òmiques tenen més informació que la que 
es pot emmagatzemar en una taula com ara dades d'anotacions, diverses 
covariables o informació sobre l'experiment.  

La classe **ExpressionSet** del paquet [Bioconductor](https://www.bioconductor.org/) 
de R, permet emmagatzemar i accedir a dades de microarrays de manera que podem 
gestionar simultàniament totes aquestes peces d'informació; és a dir, ens ajuda 
a simplificar el procés i evitar errors derivats de la falta de coherència entre
les parts.  

Les dades per aquesta pràctica les hem obtingut de la base de dades 
[GEO](https://www.ncbi.nlm.nih.gov/geo/) ( Gene Expression Omnibus), un 
repositori públic per a una àmplia gamma de dades experimentals que inclouen 
experiments basats en microarrays que mesuren l'ARNm, l'ADN genòmic i 
l'abundància de proteïnes, així com tècniques sense matriu com l'anàlisi en 
sèrie de l'expressió gènica (SAGE), dades proteòmiques d'espectrometria de 
masses i dades de seqüenciació d'alt rendiment.  

L’estudi que hem escollit és GDS1251, «A physiogenomic approach to study the 
regulation of blood pressure» que tal i com expliquen els propis autors 
«l'objectiu de aquests estudi és establir un model de cribratge fisiogenòmic per
a gens expressats de manera diferencial en la regulació de la pressió arterial 
que pogui donar una pista sobre nous mecanismes vasoreguladors.»  

Amb les dades d’aquest estudi farem una anàlisi bàsica de dades de microarrays 
per donar resposta al problema biològic que plantegen els autors.

Finalment, presentarem en aquest informe els resultats obtinguts i valorarem la
qualitat de les dades així com les diferents tècniques emprades.

# Mètodes

En l’estudi es va induir hipotensió aguda en 4 rates normotenses, suposant que 
els sistemes vasoreguladors contrarestaran la hipotensió. L'anàlisi del 
transcriptoma de microarrays es va realitzar a partir dels ronyons 6 hores 
després de la inducció de la hipotensió aguda. Els resultats es van confirmar 
mitjançant PCR en temps real. Es van fer servir 5 rates com a control.

## Preparació del sistema: directoris i paquets

Oraganitzem el projecte fent servir directoris per ordenar les dades i els 
resultats.  


```{r directoris}
workingDir <- getwd()
dataDir <- file.path(workingDir, "data")
resultsDir <- file.path(workingDir, "results")
```

Instalem els paquets requerits en cas que no ho estiguin.
Per tal que no ho faci cada vegada farme servir la funció **installifnot**. 

```{r paquets, eval = TRUE}
# De moment no l'executem perquè no ens ho faci cada vegada
if (!require(BiocManager)) install.packages("BiocManager")

installifnot <- function (pkg){
  if (!require(pkg, character.only=T)){
    BiocManager::install(pkg)
  }
}
# BiocManager::install() # Actualitza paquets instal·lats
installifnot("rae230a.db")
installifnot("mogene10sttranscriptcluster.db")
installifnot("oligo")
installifnot("limma")
installifnot("Biobase")
installifnot("arrayQualityMetrics")
installifnot("genefilter")
installifnot("annotate")
installifnot("xtable")
installifnot("gplots")
installifnot("GOstats")
installifnot("GEOquery")
installifnot("clusterProfiler")
```

## Lectura de les dades {.tabset .tabset-fade .tabset-pills}  

### Dades crues (Raw Data)

 
Les mostres estan agrupades en dos grups, les rates a què se'ls ha induït
una hipotensió aguda (Hypotension) i als qui no (Control).
Emmagatzemem aquesta informació al fitxer *targets.csv*.

```{r llegirTargets}
require(Biobase)
# Llegim l'arxiu targets.csv en un dataframe
targetsDF <- read.csv(file=file.path(dataDir,"targets.csv"), header = TRUE, sep=",") 
# Visualitzem l'arxiu targets
targetsDF

# Definim variables pels gràfics
sampleNames <- as.character(targetsDF$ShortName)
sampleColor <- as.character(targetsDF$Colors)
# Creem un objecte AnnotatedDataFrame
targets <- AnnotatedDataFrame(targetsDF)
```

Extraurem les dades del arxius .CEL que ens hem descarregat i hem guardat al 
fitxer *dades*.  

Llegim els arxius .CEL fent servir la informació continguda en el data frame
*targets*.  
Gurdarem les dades en l'objecte *rawData* que és del tipus *ExpressionFeatureSet*,
un tipus especial *d'ExpressionSet*.


```{r llegirCELFiles}
# Fitxers .CEL amb la info que hem tret de l'arxiu "target.csv"
CELfiles <- targetsDF$fileName
rawData <- read.celfiles(file.path(dataDir, CELfiles), phenoData=targets)
rawData
```

### Descàrrega de dades amb `GEOquery`

Tot i que he decidit fer tot l'estudi amb les dades crues (raw data) hi ha 
l'opció d'extreure les dades directament de la base de dades *Gene Expression 
Omnibus* [GEO](https://www.ncbi.nlm.nih.gov/geo/) fent servir la llibreria 
*GEOquery* de *Biobase (Bioconductor)*.  
Una de les ventatges és que aquestes dades ja estan normalitzades.  
  
Aquesta és la manera d'extreure les dades amb l'identificador GDS.

```{r geo}
# Carreguem la llibreria GEOquery
require(GEOquery)

# Amb l'identificador GSE de l'estudi descarreguem les dades de GEO
#gse <- getGEO("GSE2401", GSEMatrix=TRUE, AnnotGPL=TRUE)
#gseEset <- gse[[1]]
#head(exprs(gseEset))

# Amb l'identificador GDS de l'estudi descarreguem les dades de GEO
gds <- getGEO("GDS1251", GSEMatrix=TRUE, AnnotGPL=TRUE)
# Tipus d'objecte
class(gds)
head(Meta(gds))
# Asignem l'ExpressionSet
gdsEset <- GDS2eSet(gds,do.log2=FALSE)
# Veiem l'ExpressionSet
gdsEset
# Veiem les dades que conté
exprsGdsEset <- exprs(gdsEset)
head(exprsGdsEset)
```

## Exploració i control de qualitat {.tabset .tabset-fade .tabset-pills}  

Per fer l'exploració de dades farem servir primerament funcions *ad-hoc*

### Funcions "ad-hoc"

#### BOXPLOT

```{r graficsQualitat}
# Boxplot RAW data
boxplot(rawData, which="all",las=2, main="Intensity distribution of RAW data", 
        cex.axis=0.6, col=sampleColor, names=sampleNames)

# Boxplot GDS Eset
#boxplot(gdsEset, which="all",las=2, main="Intensity distribution of GDS Eset", 
#        cex.axis=0.6, col=sampleColor, names=sampleNames)
```

#### Agrupació Jeràrquica

```{r graficsQualitat2}
# Hierarquical Clustering RAW data
clust.euclid.average <- hclust(dist(t(exprs(rawData))),method="average")
plot(clust.euclid.average, labels=sampleNames, main="Hierarchical clustering del
     RawData", cex=0.7,  hang=-1)

# Hierarquical Clustering GDS Eset
#clust.euclid.average <- hclust(dist(t(exprs(gdsEset))),method="average")
#plot(clust.euclid.average, labels=sampleNames, main="Hierarchical clustering de
#GDS data", cex=0.7,  hang=-1)
```

#### Anàlisis de Components Principals (PCA)

```{r graficsQualitat3}
# Anàlisis de Components Principals 
# Definició de la funció
plotPCA <- function ( X, labels=NULL, colors=NULL, dataDesc="", scale=FALSE, formapunts=NULL, myCex=0.8,...)
{
  pcX<-prcomp(t(X), scale=scale) # o prcomp(t(X))
  loads<- round(pcX$sdev^2/sum(pcX$sdev^2)*100,1)
  xlab<-c(paste("PC1",loads[1],"%"))
  ylab<-c(paste("PC2",loads[2],"%"))
  if (is.null(colors)) colors=1
  plot(pcX$x[,1:2],xlab=xlab,ylab=ylab, col=colors, pch=formapunts, 
       xlim=c(min(pcX$x[,1])-100000, max(pcX$x[,1])+100000),
       ylim=c(min(pcX$x[,2])-100000, max(pcX$x[,2])+100000))
  text(pcX$x[,1],pcX$x[,2], labels, pos=3, cex=myCex)
  title(paste("Plot of first 2 PCs for expressions in", dataDesc, sep=" "), cex=0.8)
}

# Raw data
plotPCA(exprs(rawData), labels=sampleNames, dataDesc="raw data", colors=sampleColor,
        formapunts=c(rep(16,4),rep(17,4)), myCex=0.6)
# GDS Eset
#plotPCA(exprs(gdsEset), labels=sampleNames, dataDesc="GDS Eset", colors=sampleColor,
#        formapunts=c(rep(16,4),rep(17,4)), myCex=0.6)
```


Guardem els anàlisi de qualitat en un arxiu PDF en el directori *results*  

```{r graficsQualitatAPDF}
# Ho gravem a un arxiu pdf al directori "results"
pdf(file.path(resultsDir, "QCPlots_Raw.pdf"))
boxplot(rawData, which="all",las=2, main="Intensity distribution of RAW data", 
        cex.axis=0.6, col=sampleColor, names=sampleNames)
plot(clust.euclid.average, labels=sampleNames, main="Hierarchical clustering of samples of RawData", 
     cex=0.7,  hang=-1)
plotPCA(exprs(rawData), labels=sampleNames, dataDesc="raw data", colors=sampleColor,
        formapunts=c(rep(16,4),rep(17,4)), myCex=0.6)
# Tanquem l'arxiu
dev.off()

```


### Amb el paquet `arrayQualityMetrics`


Creem el directori *QC_RawData*  on tindrem els resultats de l'anàlisis de 
qualitat fet per "arrayQualityMetrics"
El control de qualitat amb *arrayQualityMetrics* consumeix cert temps pel que 
podem optar per executar-ho, o no fer-ho, usant una variable de tipus lògic.

```{r arrayQM}
# Carreguem la llibreria "arrayQualityMetrics"
require(arrayQualityMetrics)

# Evitem tornar-lo a executar cada vegada que s'executa l'script.
rerun <- FALSE
if(rerun){
  # Raw Data
  arrayQualityMetrics(rawData,  reporttitle="QC_RawData", force=TRUE)
  # GDS Eset
  #arrayQualityMetrics(gdsEset,  reporttitle="QC_GDSEset", force=TRUE)
}
```

## Normalització

Fem servir el mètode RMA per normalitzar les dades Raw Data.  

```{r normalitzacio}
# Normalitzem les dades Raw Data
myEset <- rma(rawData)
write.exprs(myEset, file.path(resultsDir, "NormData.txt"))
myEset
```

Cal recordad que les dades descarregades amb GDS ja estan normalitzades.

## Filtratge


```{r filtratge}
require(genefilter)
# Farem la base de dades rae230a.db que és la que correspon a la plataforma 
# GPL0341 d'Affymetrix (microarray)
annotation(myEset) <- "rae230a.db"
eset_filtered <- nsFilter(myEset, var.func=IQR,
         var.cutoff=0.75, var.filter=TRUE, require.entrez = TRUE,
         filterByQuantile=TRUE)
# Nombre de gens filtrats (esborrats)
print(eset_filtered)

# Nombre de Gens que resten
print(eset_filtered$eset)
```

Extraiem la matriu de dades filtrades que farem servir per continuar l'estudi.

```{r Dadesflitrades}
filteredEset <- eset_filtered$eset
filteredData <- exprs(filteredEset)
# Assignem el nom de les columnes els que hem definit a l'arxiu 'targets.csv'
colnames(filteredData) <- pData(filteredEset)$ShortName
# Visualitzem les primeres files
head(filteredData)
```


## Selecció de gens

Construïm una matriu de disseny i una de contrast per l'anàlisis amb un model 
lineal.

**Matriu de disseny**

```{r linearModel}
library(limma)
treat <- pData(filteredEset)$groups
lev <- factor(treat, levels = unique(treat))
design <-model.matrix(~0+lev)
colnames(design) <- levels(lev)
rownames(design) <- sampleNames
print(design)
```
  
**Matriu de contrast**

```{r linearModel2}
#COMPARISON
cont.matrix1 <- makeContrasts( 
        Hypotension.vs.Control = Hypotesion-Control,
        levels = design)
comparisonName <- "Efecte de la hipotensió induida"
print(cont.matrix1)
```

Estimació del model lineal

```{r estimaModel}
# Estimació del model (F)
fit1 <- lmFit(filteredData, design)
fit.main1 <- contrasts.fit(fit1, cont.matrix1)
fit.main1 <- eBayes(fit.main1)
```


El resultat de l'anàlisi es troba a l'objecte `lmfit` i es pot extreure amb la 
instrucció *topTable*.

La instrucció `topTable` pot aplicar un filtre automàtic. En el nostra cas 
ens quedarem únicament els gens amb un "log-fold-change" major que 0 i un 
p-valor ajustat inferior a 0.05.

```{r results1}
# Fem servir l'instrucció "topTable"
topTab <-  topTable (fit.main1, number=nrow(fit.main1), coef="Hypotension.vs.Control", 
                     adjust="fdr",lfc=0, p.value=0.05)
# Veiem la seva dimensió
dim(topTab)
# Observem els 10 primers resultats
head(topTab, n=10)
```

# Resultats 


## Anotació dels resultats

Obtenim els identificadors ENTREZ, SYMBOL i GENENAME corresponents als
probesets (identificats amb els id de la companyia que va produir el microarray)
que apareixen a la taula de resultats. 
 
En el nostre cas la companyia és *Affymetrix* i segons les seves expecificacions
per els microarrays que s'han fet servir *(Platform GPL0341)* la base de dades 
que hem de fer servir és `rae230a.db`.

```{r}
require(rae230a.db)
# Veiem quins tipus d'identificadors 
keytypes(rae230a.db)
# Guardem les anotacions
anotacions <- AnnotationDbi::select (rae230a.db, keys=rownames(filteredData), 
                                      columns=c("ENTREZID","SYMBOL","GENENAME"))
```

Afegim les columnes d'anotacions a la topTable. Utilitzem funcions del paquet
`dplyr` i "pipes" (%\>%) per concatenar les instruccions.
La columna "GENENAME" la afegim al final de la taula per a una lectura més 
còmoda.

```{r}
require(dplyr)
# Afegim la columna "GENENAME"
topTabAnotada <- topTab %>%  
  mutate(PROBEID=rownames(topTab)) %>%
  left_join(anotacions) %>% 
  arrange(P.Value) %>%
  select(7,8,9, 1:6, 10)
# Visualitzem els 10 primers resultatss
head(topTabAnotada, n=10)
```

Escribin el resultat en un arxiu de text o a un arxiu html.

```{r}
write.csv2(topTabAnotada, file= file.path(resultsDir,"Gens_seleccionats.csv"))
print(xtable(topTab,align="lllllll"),type="html",html.table.attributes="",
      file=file.path(resultsDir,"Gens_seleccionats.html"))
```


## Visualització de resultats (1): Volcano Plot


```{r volcanoPlot}
# Anomenem amb SYMBOL els gens del model. Fem servir la base de dades 
# d'anotacions rae230a.db
genenames <- AnnotationDbi::select(rae230a.db, 
                    rownames(fit.main1), c("SYMBOL"))$SYMBOL
volcanoplot(fit.main1, highlight=10, names=genenames, 
            main = paste("Gens diferencialment expresats", colnames(cont.matrix1), sep="\n"))
abline(v = c(-3, 3))

# El guardem a un pdf
pdf(file.path(resultsDir,"VolcanoPlot.pdf"))
volcanoplot(fit.main1, highlight = 10, names = genenames, 
            main = paste("Gens diferencialment expresats", colnames(cont.matrix1), sep = "\n"))
abline(v = c(-3, 3))
dev.off()
```

## Visualizació de resultats (2): Heatmaps

```{r heatmap}
selectedRows <- rownames(filteredData) %in% rownames(topTab)
selectedData <- filteredData[selectedRows,]

# Heatmap Plot
my_palette <- colorRampPalette(c("blue", "red"))(n = 299)
library(gplots)
heatmap.2(selectedData,
          Rowv=TRUE,
          Colv=TRUE,
          main="HeatMap Induced.vs.WT FC>=1",
          scale="row",
          col=my_palette,
          sepcolor="white",
          sepwidth=c(0.05,0.05),
          cexRow=0.5,
          cexCol=0.9,
          key=TRUE,
          keysize=1.5,
          density.info="histogram",
          ColSideColors=c(rep("blue",5),rep("red",4)),
          tracecol=NULL,
          srtCol=30)
pdf(file.path(resultsDir,"Heatmap.pdf"))

# El guardem a un pdf
heatmap.2(selectedData,
          Rowv=TRUE,
          Colv=TRUE,
          main="HeatMap Induced.vs.WT FC>=1",
          scale="row",
          col=my_palette,
          sepcolor="white",
          sepwidth=c(0.05,0.05),
          cexRow=0.5,
          cexCol=0.9,
          key=TRUE,
          keysize=1.5,
          density.info="histogram",
          ColSideColors=c(rep("blue",5),rep("red",4)),
          tracecol=NULL,
          srtCol=30)
dev.off()
```

## Anàlisi de significació biològica

A títol il·lustratiu farem una anàlisi d'enriquiment ("Over-Representation Analysis") a partir de la llista de gens seleccionats com a diferencialment expressats.

Per a l'anàlisi necessitem dues col·leccions de gens

- La llista seleccionada
- L'univers de gens és a dir tots els gens que s'han inclòs en l'anàlisi (hi ha qui posa tots els del xip o tots els del genoma).

La majoria de programes necessiten que els identificadors dels gens siguin en format "ENTREZ" per la qual cosa prepararem les dues llistes alhora (encara que ja teníem la dels gens seleccionats).

```{r}
require(rae230a.db)
probesUniverse <- rownames(filteredData)
entrezUniverse<- AnnotationDbi::select(rae230a.db, probesUniverse, "ENTREZID")$ENTREZID

topProbes <-   rownames(selectedData)
entrezTop<- AnnotationDbi::select(rae230a.db, topProbes, "ENTREZID")$ENTREZID

# Eliminamos posibles duplicados

topGenes <- entrezTop[!duplicated(entrezTop)]
entrezUniverse <- entrezUniverse[!duplicated(entrezUniverse)]
```

Se pueden utilizar muchos paquetes para realizar un análisis de enriquecimiento genético. Cada uno de ellos realiza un análisis ligeramente diferente, pero las ideas subyacentes son las mismas.

En este ejemplo usamos "GOstats", que fue uno de los primeros paquetes disponibles en Bioconductor para realizar análisis de enriquecimiento.

La idea para usarlo es bastante simple: necesitamos crear un tipo especial de objeto llamado "Hiperparámetro" que puede ser de clase:

-   `GOHyperGParams` para hacer un análisis basado en la Gene Ontology,
-   `KEGGHyperGParams` para hacer un análisis basado en la base de datos REACTOMA,
-   `PFAMHyperGParams` para basar el análisis en la base de daos PFAM.

```{r createHyperparameter}
require (GOstats)

# This parameter has an "ontology" argument. It may be "BP", "MF" or "CC"
# Other arguments are taken by default. Check the help for more information.

GOparams = new("GOHyperGParams",
    geneIds=topGenes, universeGeneIds=entrezUniverse,
    annotation="rae230a.db", ontology="BP",
    pvalueCutoff=0.01)
```

Fem anar l'anàlisis  

```{r runORAnalysis}
# Fem l'anàlisis  
GOhyper = hyperGTest(GOparams)
```

Extraiem resultats del summary.  

```{r summarizeORAesults}
head(summary(GOhyper), n=10)
dim(summary(GOhyper))
```

Guardem els resultats en un informe html.  

```{r ORAreport}
# Creem un informe html amb els resultats
GOfilename =file.path(resultsDir, "GOResults.html")
htmlReport(GOhyper, file = GOfilename, summary.args=list("htmlLinks"=TRUE))
```

```{r clusterProfiler}
library(clusterProfiler)

## Run GO enrichment analysis 

ego <- enrichGO(gene = as.integer(topGenes), # selgenes, 
                # universe = entrezUniverse, # universe = all_genes,
                keyType = "ENTREZID",
                OrgDb = rae230a.db, 
                ont = "BP", 
                pAdjustMethod = "BH", 
                qvalueCutoff = 0.1, 
                readable = TRUE)
head(ego, n=10)
```



# Discusió



# Referències

[@GDS1251]

