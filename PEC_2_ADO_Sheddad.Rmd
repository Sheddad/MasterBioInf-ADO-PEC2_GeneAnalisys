---
title: "PEC 2 Anàlisis de Dades Òmiques"
author: "Sheddad Kaid-Salah Ferrón"
date: "`r format(Sys.Date())`"
params:
  printcode:
    label: "Display Code:"
    value: TRUE # or set it to FALSE
  data:
    label: "Raw data .fastq:"
    value: S07_Ves02_read1.fastq
    input: file
output:
   html_document:
    code_folding: hide
    toc: true
    toc_float: no
    toc_depth: 3
    theme: flatly
    highlight: textmate
    number_sections: true
    csl: vancouver.csl
editor_options: 
  chunk_output_type: console
bibliography: PEC2_ADO_Ref.bib
---

```{r class.source = 'fold-hide', setup, include=FALSE}
library(knitr)
library(rmdformats)

## Global options
options(max.print="75")
opts_chunk$set(echo=TRUE,
	             cache=FALSE,
               prompt=FALSE,
               tidy=TRUE,
               comment=NA,
               message=FALSE,
               warning=FALSE)
opts_knit$set(width=75)
```

# Introducció i Objectius

## Preparació del sistema: directoris i paquets

Oraganitzem el projecte fent servir directoris per organitzar les dades i els 
resultats.  


```{r directoris}
workingDir <- getwd()
dataDir <- file.path(workingDir, "data")
resultsDir <- file.path(workingDir, "results")
```

Instalem els paquets requerits en cas que no ho estiguin.
Per tal que no ho faci cada vegada farme servir la funció **installifnot**. 
REF:

```{r paquets, eval = TRUE}
# De moment no l'executem perquè no ens ho faci cada vegada
if (!require(BiocManager)) install.packages("BiocManager")

installifnot <- function (pkg){
  if (!require(pkg, character.only=T)){
    BiocManager::install(pkg)
  }
}
# BiocManager::install() # Actualitza paquets instal·lats
installifnot("rae230a.db")
installifnot("mogene10sttranscriptcluster.db")
installifnot("oligo")
installifnot("limma")
installifnot("Biobase")
installifnot("arrayQualityMetrics")
installifnot("genefilter")
installifnot("annotate")
installifnot("xtable")
installifnot("gplots")
installifnot("GOstats")

installifnot("GEOquery")
```

## Lectura de les dades

Les mostres estan agrupades en dos grups, els ratolins a què se'ls ha induït
una hipotensió aguda i als qui no.
Emmagatzemem aquesta informació al fitxer **targets.csv**.

```{r llegirTargets}
require(Biobase)
# Llegim l'arxiu targets.csv en un dataframe
targetsDF <- read.csv(file=file.path(dataDir,"targets.csv"), header = TRUE, sep=",") 
# Definim variables pels gràfics
sampleNames <- as.character(targetsDF$ShortName)
sampleColor <- as.character(targetsDF$Colors)
# Creem un objecte AnnotatedDataFrame
targets <- AnnotatedDataFrame(targetsDF)
```

Ara llegim els arxius .CEL fent servir la informació continguda en el data frame
**targets**
```{r llegirCELFiles}
# Fitxers .CEL amb la info que hem tret de l'arxiu "target.csv"
CELfiles <- targetsDF$fileName
rawData <- read.celfiles(file.path(dataDir, CELfiles), phenoData=targets)
rawData
```


## Descàrrega de dades amb `GEOquery`

```{r filtrado}
# Carreguem la llibreria GEOquery
require(GEOquery)

# Amb l'identificador GSE de l'estudi descarreguem les dades de GEO
#gse <- getGEO("GSE2401", GSEMatrix=TRUE, AnnotGPL=TRUE)
#gseEset <- gse[[1]]
#head(exprs(gseEset))

# Amb l'identificador GDS de l'estudi descarreguem les dades de GEO
gds <- getGEO("GDS1251", GSEMatrix=TRUE, AnnotGPL=TRUE)
# Tipus d'objecte
class(gds)
head(Meta(gds))
# Asignem l'ExpressionSet
gdsEset <- GDS2eSet(gds,do.log2=FALSE)
gdsEset
exprsGdsEset <- exprs(gdsEset)
head(exprsGdsEset)
```

## Exploració i control de qualitat {.tabset .tabset-fade .tabset-pills}  

### Funcions "ad-hoc"

```{r graficsQualitat}
# Boxplot RAW data
boxplot(rawData, which="all",las=2, main="Intensity distribution of RAW data", 
        cex.axis=0.6, col=sampleColor, names=sampleNames)

# Boxplot GDS Eset
boxplot(gdsEset, which="all",las=2, main="Intensity distribution of GDS Eset", 
        cex.axis=0.6, col=sampleColor, names=sampleNames)
```

```{r graficsQualitat2}
# Hierarquical Clustering RAW data
clust.euclid.average <- hclust(dist(t(exprs(rawData))),method="average")
plot(clust.euclid.average, labels=sampleNames, main="Hierarchical clustering del RawData", cex=0.7,  hang=-1)

# Hierarquical Clustering GDS Eset
clust.euclid.average <- hclust(dist(t(exprs(gdsEset))),method="average")
plot(clust.euclid.average, labels=sampleNames, main="Hierarchical clustering de GDS data", cex=0.7,  hang=-1)
```

```{r graficsQualitat3}
# Anàlisis de Components Principals 
# Definició de la funció
plotPCA <- function ( X, labels=NULL, colors=NULL, dataDesc="", scale=FALSE, formapunts=NULL, myCex=0.8,...)
{
  pcX<-prcomp(t(X), scale=scale) # o prcomp(t(X))
  loads<- round(pcX$sdev^2/sum(pcX$sdev^2)*100,1)
  xlab<-c(paste("PC1",loads[1],"%"))
  ylab<-c(paste("PC2",loads[2],"%"))
  if (is.null(colors)) colors=1
  plot(pcX$x[,1:2],xlab=xlab,ylab=ylab, col=colors, pch=formapunts, 
       xlim=c(min(pcX$x[,1])-100000, max(pcX$x[,1])+100000),
       ylim=c(min(pcX$x[,2])-100000, max(pcX$x[,2])+100000))
  text(pcX$x[,1],pcX$x[,2], labels, pos=3, cex=myCex)
  title(paste("Plot of first 2 PCs for expressions in", dataDesc, sep=" "), cex=0.8)
}

# Raw data
plotPCA(exprs(rawData), labels=sampleNames, dataDesc="raw data", colors=sampleColor,
        formapunts=c(rep(16,4),rep(17,4)), myCex=0.6)
# GDS Eset
plotPCA(exprs(gdsEset), labels=sampleNames, dataDesc="GDS Eset", colors=sampleColor,
        formapunts=c(rep(16,4),rep(17,4)), myCex=0.6)
```

```{r graficosCalidadAPDF}
# Ho gravemn a un arxiu pdf al directori "results"
pdf(file.path(resultsDir, "QCPlots_Raw.pdf"))
boxplot(rawData, which="all",las=2, main="Intensity distribution of RAW data", 
        cex.axis=0.6, col=sampleColor, names=sampleNames)
plot(clust.euclid.average, labels=sampleNames, main="Hierarchical clustering of samples of RawData", 
     cex=0.7,  hang=-1)
plotPCA(exprs(rawData), labels=sampleNames, dataDesc="raw data", colors=sampleColor,
        formapunts=c(rep(16,4),rep(17,4)), myCex=0.6)
# Tanquem l'arxiu
dev.off()

```


### Amb el paquet `arrayQualityMetrics`


Creem el directori *QC_RawData*  on tindrem els resultats de l'anàlisis de 
qualitat fet per "arrayQualityMetrics"
El control de qualitat amb *arrayQualityMetrics* consumeix cert temps pel que 
podem optar per executar-ho, o no fer-ho, usant una variable de tipus lògic.

```{r arrayQM}
# Carreguem la llibreria "arrayQualityMetrics"
require(arrayQualityMetrics)

# Evitem tornar-lo a executar cada vegada que s'executa l'script.
rerun <- FALSE
if(rerun){
  # Raw Data
  arrayQualityMetrics(rawData,  reporttitle="QC_RawData", force=TRUE)
  # GDS Eset
  arrayQualityMetrics(gdsEset,  reporttitle="QC_GDSEset", force=TRUE)
}
```

## Normalització

Fem servir el mètode RMA per normalitzar les dades Raw Data.

```{r normalitzacio}
# Normalitzem les dades Raw Data
myEset <- rma(rawData)
write.exprs(myEset, file.path(resultsDir, "NormData.txt"))
myEset
```

Les dades descarregades amb GDS ja estan normalitzades

## Filtratge

???

```{r filtrado }
require(genefilter)
# Farem la base de dades rae230a.db que és la que correspon a la plataforma 
# GPL0341 d'Affymetrix (microarray)
annotation(myEset) <- "rae230a.db"
eset_filtered <- nsFilter(myEset, var.func=IQR,
         var.cutoff=0.75, var.filter=TRUE, require.entrez = TRUE,
         filterByQuantile=TRUE)
# Nombre de gens filtrats (esborrats)
print(eset_filtered)

# Nombre de Gens que resten
print(eset_filtered$eset)
```

La matriz de datos filtrados se extrae del objeto \`filtered$eset$ y se utilizará en los pasos siguientes.

```{r Datosfiltrados}
filteredEset <- eset_filtered$eset
filteredEset <- myEset
filteredData <- exprs(filteredEset)
filteredData <- exprs(myEset)
head(filteredData)
#colnames(filteredData) <- pData(eset_filtered$eset)$ShortName
colnames(filteredData) <- pData(filteredEset)$ShortName
```


# Mètodes

## Selección de genes

Construimos un modelo lineal, es decir una matriz de diseño y una de contrastes, para el análisis.

Primero la matriz de diseño

```{r linearModel}
library(limma)
treat <- pData(filteredEset)$groups
lev <- factor(treat, levels = unique(treat))
design <-model.matrix(~0+lev)
colnames(design) <- levels(lev)
rownames(design) <- sampleNames
print(design)
```


A continuación la matriz de contraste

```{r linearModel2}
#COMPARISON
cont.matrix1 <- makeContrasts( 
        Hypotension.vs.Control = Hypotesion-Control,
        levels = design)
comparisonName <- "Efecte de la hipotensió induida"
print(cont.matrix1)
```

Estimamos el modelo

```{r estimaModelo}
#MODEL FIT
fit1 <- lmFit(filteredData, design)
fit.main1 <- contrasts.fit(fit1, cont.matrix1)
fit.main1 <- eBayes(fit.main1)
```


El resultado del análisis se encuentra en el objeto `lmfit` y puede extraerse con la instrucción "topTable".

Recordemos que la instrucción `topTable` puede aplicar un filtro automàtico, basado en dos criterios distintos, "log fold change" y "p.value". En este caso retenemos únicamente los genes con un "log-fold-change" mayor de 3 y un p-valor ajustado inferior a 0.05

```{r results1}
topTab <-  topTable (fit.main1, number=nrow(fit.main1), coef="Hypotension.vs.Control", adjust="fdr",lfc=1, p.value=0.05)
dim(topTab)
head(topTab)
```

# Resultats 


## Anotación de los resultados

Obtenemos los identificadores ENTREZ y GENE SYMBOL correspondientes a los probesets (identificados con los id de la compañía que produjo el microarray) que aparecen en la tabla de resultados.

```{r}
require(rae230a.db)
keytypes(rae230a.db)
anotaciones <- AnnotationDbi::select (rae230a.db, keys=rownames(filteredData), columns=c("ENTREZID", "SYMBOL", "GENENAME"))
```

Añadimos las columnas de anotaciones a la "topTable".

Aunque esto se puede hacer de muchas formas utilizamos la metodología de concatenar las instrucciones usando "pipes" (%\>%) y funciones del paquete `dplyr` que simplifican la lectura.

```{r}
library(dplyr)
topTabAnotada <- topTab %>%  
  mutate(PROBEID=rownames(topTab)) %>%
  left_join(anotaciones) %>% 
  arrange(P.Value) %>%
  select(7,8,9, 1:6, 10)

head(topTabAnotada)
```

## Visualización de resultados (1): Volcano Plot

```{r volcanoPlot}
# Anomenem amb SYMBOL els gens del model. Fem servir la base de dades 
# d'anotacions rae230a.db
genenames <- AnnotationDbi::select(rae230a.db, 
                    rownames(fit.main1), c("SYMBOL"))$SYMBOL
volcanoplot(fit.main1, highlight=10, names=genenames, 
            main = paste("Gens diferencialment expresats", colnames(cont.matrix1), sep="\n"))
abline(v = c(-3, 3))

# El guardem a un pdf
pdf(file.path(resultsDir,"VolcanoPlot.pdf"))
volcanoplot(fit.main1, highlight = 10, names = genenames, 
            main = paste("Gens diferencialment expresats", colnames(cont.matrix1), sep = "\n"))
abline(v = c(-3, 3))
dev.off()
```

## Visualización de resultados (2): Heatmaps

```{r heatmap}
selectedRows <- rownames(filteredData) %in% rownames(topTab)
selectedData <- filteredData[selectedRows,]

#HEATMAP PLOT
my_palette <- colorRampPalette(c("blue", "red"))(n = 299)
library(gplots)
heatmap.2(selectedData,
          Rowv=TRUE,
          Colv=TRUE,
          main="HeatMap Induced.vs.WT FC>=1",
          scale="row",
          col=my_palette,
          sepcolor="white",
          sepwidth=c(0.05,0.05),
          cexRow=0.5,
          cexCol=0.9,
          key=TRUE,
          keysize=1.5,
          density.info="histogram",
          ColSideColors=c(rep("blue",5),rep("red",4)),
          tracecol=NULL,
          srtCol=30)
pdf(file.path(resultsDir,"Heatmap.pdf"))
heatmap.2(selectedData,
          Rowv=TRUE,
          Colv=TRUE,
          main="HeatMap Induced.vs.WT FC>=3",
          scale="row",
          col=my_palette,
          sepcolor="white",
          sepwidth=c(0.05,0.05),
          cexRow=0.5,
          cexCol=0.9,
          key=TRUE,
          keysize=1.5,
          density.info="histogram",
          ColSideColors=c(rep("red",4),rep("blue",4)),
          tracecol=NULL,
          srtCol=30)
dev.off()
```


# Discusió

# Referències

[@GDS1251]

