---
title: "PEC 2 Anàlisis de Dades Òmiques"
author: "Sheddad Kaid-Salah Ferrón"
date: "`r format(Sys.Date())`"
params:
  printcode:
    label: "Display Code:"
    value: TRUE # or set it to FALSE
  data:
    label: "Raw data .fastq:"
    value: S07_Ves02_read1.fastq
    input: file
output:
   html_document:
    code_folding: hide
    toc: true
    toc_float: no
    toc_depth: 3
    theme: flatly
    highlight: textmate
    number_sections: true
    csl: vancouver.csl
editor_options: 
  chunk_output_type: console
bibliography: PEC2_ADO_Ref.bib

---

```{r class.source = 'fold-hide', setup, include=FALSE}
library(knitr)
library(rmdformats)

## Global options
options(max.print="75")
opts_chunk$set(echo=TRUE,
	             cache=FALSE,
               prompt=FALSE,
               tidy=TRUE,
               comment=NA,
               message=FALSE,
               warning=FALSE)
opts_knit$set(width=75)
```

# Introducció i Objectius

## Preparació del sistema: directoris i paquets

Oraganitzem el projecte fent servir directoris per organitzar les dades i els 
resultats.  


```{r directoris}
workingDir <- getwd()
dataDir <- file.path(workingDir, "data")
resultsDir <- file.path(workingDir, "results")
```

Instalem els paquets requerits en cas que no ho estiguin.
Per tal que no ho faci cada vegada farme servir la funció **installifnot**. 
REF:

```{r paquets, eval = TRUE}
# De moment no l'executem perquè no ens ho faci cada vegada
if (!require(BiocManager)) install.packages("BiocManager")

installifnot <- function (pkg){
  if (!require(pkg, character.only=T)){
    BiocManager::install(pkg)
  }
}
# BiocManager::install() # Actualitza paquets instal·lats
installifnot("rae230a.db")
installifnot("mogene10sttranscriptcluster.db")
installifnot("oligo")
installifnot("limma")
installifnot("Biobase")
installifnot("arrayQualityMetrics")
installifnot("genefilter")
installifnot("annotate")
installifnot("xtable")
installifnot("gplots")
installifnot("GOstats")

installifnot("GEOquery")
```

## Lectura de les dades

Les mostres estan agrupades en dos grups, els ratolins a què se'ls ha induït
una hipotensió aguda i als qui no.
Emmagatzemem aquesta informació al fitxer **targets.csv**.

```{r llegirTargets}
require(Biobase)
# Llegim l'arxiu targets.csv en un dataframe
targetsDF <- read.csv(file=file.path(dataDir,"targets.csv"), header = TRUE, sep=",") 
# Definim variables pels gràfics
sampleNames <- as.character(targetsDF$ShortName)
sampleColor <- as.character(targetsDF$Colors)
# Creem un objecte AnnotatedDataFrame
targets <- AnnotatedDataFrame(targetsDF)
```

Ara llegim els arxius .CEL fent servir la informació continguda en el data frame
**targets**
```{r llegirCELFiles}
# Fitxers .CEL amb la info que hem tret de l'arxiu "target.csv"
CELfiles <- targetsDF$fileName
rawData <- read.celfiles(file.path(dataDir, CELfiles), phenoData=targets)
rawData
```


## Descàrrega de dades amb `GEOquery`

```{r filtrado}
# Carreguem la llibreria
require(GEOquery)
# Amb l'identificador de l'estudi descarreguem les dades de GEO
gse <- getGEO("GSE2401", GSEMatrix=TRUE, AnnotGPL=TRUE)
class(gse)
names(gse)
length(gse)
gse[[1]]
esetFromGEO <- gse[[1]]
head(exprs(esetFromGEO))

gds <- getGEO("GDS1251", GSEMatrix=TRUE, AnnotGPL=TRUE)

```

## Exploració i control de qualitat {.tabset .tabset-fade .tabset-pills}  

### Funcions "ad-hoc"

```{r graficosCalidad}
# Boxplot
boxplot(rawData, which="all",las=2, main="Intensity distribution of RAW data", 
        cex.axis=0.6, col=sampleColor, names=sampleNames)
```

```{r graficosCalidad2}
# HIERARQUICAL CLUSTERING
clust.euclid.average <- hclust(dist(t(exprs(rawData))),method="average")
plot(clust.euclid.average, labels=sampleNames, main="Hierarchical clustering of RawData", cex=0.7,  hang=-1)
```

```{r graficosCalidad3}
# Anaàlisis de Components Principals
plotPCA <- function ( X, labels=NULL, colors=NULL, dataDesc="", scale=FALSE, formapunts=NULL, myCex=0.8,...)
{
  pcX<-prcomp(t(X), scale=scale) # o prcomp(t(X))
  loads<- round(pcX$sdev^2/sum(pcX$sdev^2)*100,1)
  xlab<-c(paste("PC1",loads[1],"%"))
  ylab<-c(paste("PC2",loads[2],"%"))
  if (is.null(colors)) colors=1
  plot(pcX$x[,1:2],xlab=xlab,ylab=ylab, col=colors, pch=formapunts, 
       xlim=c(min(pcX$x[,1])-100000, max(pcX$x[,1])+100000),
       ylim=c(min(pcX$x[,2])-100000, max(pcX$x[,2])+100000))
  text(pcX$x[,1],pcX$x[,2], labels, pos=3, cex=myCex)
  title(paste("Plot of first 2 PCs for expressions in", dataDesc, sep=" "), cex=0.8)
}

plotPCA(exprs(rawData), labels=sampleNames, dataDesc="raw data", colors=sampleColor,
        formapunts=c(rep(16,4),rep(17,4)), myCex=0.6)
```

```{r graficosCalidadAPDF}
# Ho gravemn a un arxiu pdf al directori "results"
pdf(file.path(resultsDir, "QCPlots_Raw.pdf"))
boxplot(rawData, which="all",las=2, main="Intensity distribution of RAW data", 
        cex.axis=0.6, col=sampleColor, names=sampleNames)
plot(clust.euclid.average, labels=sampleNames, main="Hierarchical clustering of samples of RawData", 
     cex=0.7,  hang=-1)
plotPCA(exprs(rawData), labels=sampleNames, dataDesc="raw data", colors=sampleColor,
        formapunts=c(rep(16,4),rep(17,4)), myCex=0.6)
# Tanquem l'arxiu
dev.off()

```


### Amb el paquet `arrayQualityMetrics`


Creem el directori *QC_RawData*  on tindrem els resultats de l'anàlisis de 
qualitat fet per "arrayQualityMetrics"
El control de qualitat amb *arrayQualityMetrics* consumeix cert temps pel que 
podem optar per executar-ho, o no fer-ho, usant una variable de tipus lògic.

```{r arrayQM}
# Carreguem la llibreria "arrayQualityMetrics"
require(arrayQualityMetrics)

# Evitem tornar-lo a executar cada vegada que s'executa l'script.
rerun <- FALSE
if(rerun){
  arrayQualityMetrics(esetFromGEO,  reporttitle="QC_RawData", force=TRUE)
}
```

## Normalització

Fem servir el mètode RMA

```{r normalitzacio}
eset <- rma(rawData)
write.exprs(eset, file.path(resultsDir, "NormData.txt"))
eset
```

## Filtratge

???

```{r filtrado }
require(genefilter)
annotation(eset) <- "rae230a.db"
eset_filtered <- nsFilter(eset, var.func=IQR,
         var.cutoff=0.75, var.filter=TRUE, require.entrez = TRUE,
         filterByQuantile=TRUE)
#NUMBER OF GENES REMOVED
print(eset_filtered)

#NUMBER OF GENES IN
print(eset_filtered$eset)
```

La matriz de datos filtrados se extrae del objeto \`filtered$eset$ y se utilizará en los pasos siguientes.

```{r Datosfiltrados}
#filteredEset <- eset_filtered$eset
filteredEset <- eset
#filteredData <- exprs(filteredEset)
filteredData <- exprs(filteredEset)
#colnames(filteredData) <- pData(eset_filtered$eset)$ShortName
colnames(filteredData) <- pData(filteredEset)$ShortName
```


# Mètodes

## Selección de genes

Construimos un modelo lineal, es decir una matriz de diseño y una de contrastes, para el análisis.

Primero la matriz de diseño

```{r linearModel}
library(limma)
treat <- pData(filteredEset)$groups
lev <- factor(treat, levels = unique(treat))
design <-model.matrix(~0+lev)
colnames(design) <- levels(lev)
rownames(design) <- sampleNames
print(design)
```


A continuación la matriz de contraste

```{r linearModel2}
#COMPARISON
cont.matrix1 <- makeContrasts( 
        Hypotension.vs.Normal = Hypotesion-Normal,
        levels = design)
comparisonName <- "Efecte de la hipotensió induida"
print(cont.matrix1)
```

Estimamos el modelo

```{r estimaModelo}
#MODEL FIT
fit1 <- lmFit(filteredData, design)
fit.main1 <- contrasts.fit(fit1, cont.matrix1)
fit.main1 <- eBayes(fit.main1)
```


El resultado del análisis se encuentra en el objeto `lmfit` y puede extraerse con la instrucción "topTable".

Recordemos que la instrucción `topTable` puede aplicar un filtro automàtico, basado en dos criterios distintos, "log fold change" y "p.value". En este caso retenemos únicamente los genes con un "log-fold-change" mayor de 3 y un p-valor ajustado inferior a 0.05

```{r results1}
topTab <-  topTable (fit.main1, number=nrow(fit.main1), coef="Hypotension.vs.Normal", adjust="fdr", lfc=1)
dim(topTab)
head(topTab)
```

# Resultats 


## Anotación de los resultados

Obtenemos los identificadores ENTREZ y GENE SYMBOL correspondientes a los probesets (identificados con los id de la compañía que produjo el microarray) que aparecen en la tabla de resultados.

```{r}
require(rae230a.db)
keytypes(rae230a.db)
anotaciones <- AnnotationDbi::select (rae230a.db, keys=rownames(filteredData), columns=c("ENTREZID", "SYMBOL"))
```

Añadimos las columnas de anotaciones a la "topTable".

Aunque esto se puede hacer de muchas formas utilizamos la metodología de concatenar las instrucciones usando "pipes" (%\>%) y funciones del paquete `dplyr` que simplifican la lectura.

```{r}
library(dplyr)
topTabAnotada <- topTab %>%  
  mutate(PROBEID=rownames(topTab)) %>%
  left_join(anotaciones) %>% 
  arrange(P.Value) %>%
  select(7,8,9, 1:6)

head(topTabAnotada)
```


# Discusió

# Referències

[@GDS1251]

